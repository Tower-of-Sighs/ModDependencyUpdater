use serde_json::{json, Value};
use std::collections::HashMap;
use std::path::Path;

#[derive(Clone)]
struct ClassMaps {
    yarn_named_to_inter: HashMap<String, String>,
    yarn_inter_to_named: HashMap<String, String>,
    moj_inter_to_named: HashMap<String, String>,
    moj_named_to_inter: HashMap<String, String>,
}

#[derive(Clone)]
struct MemberMaps {
    yarn_named_to_inter_by_class: HashMap<String, HashMap<String, String>>,
    yarn_inter_to_named_by_class: HashMap<String, HashMap<String, String>>,
    moj_inter_to_named_by_class: HashMap<String, HashMap<String, String>>,
    moj_named_to_inter_by_class: HashMap<String, HashMap<String, String>>,
}

#[derive(Clone)]
struct Maps {
    class_maps: ClassMaps,
    method_maps: MemberMaps,
    field_maps: MemberMaps,
}

fn disclaimer_lines() -> Vec<String> {
    vec![
        "# Automatically generated by AW-AT Converter.".to_string(),
        "# DISCLAIMER: This file is provided \"as is\" without any warranty.".to_string(),
        "# Users must manually verify the correctness of the mappings.".to_string(),
        "# The author is not responsible for any issues caused by incorrect translation."
            .to_string(),
    ]
}

async fn fetch_mappings(ns: &str, version: &str) -> anyhow::Result<Value> {
    let client = crate::util::http_client()?;
    let url = format!(
        "https://linkieapi.shedaniel.me/api/mappings?namespace={}&version={}",
        ns, version
    );
    let resp = crate::util::send_with_retry(client.get(url), 2).await?;
    let v: Value = resp.json().await?;
    Ok(v)
}

fn build_maps_from_yarn(v: &Value) -> (ClassMaps, MemberMaps, MemberMaps) {
    let mut class_named_to_inter = HashMap::new();
    let mut class_inter_to_named = HashMap::new();
    let mut method_named_to_inter_by_class: HashMap<String, HashMap<String, String>> =
        HashMap::new();
    let mut method_inter_to_named_by_class: HashMap<String, HashMap<String, String>> =
        HashMap::new();
    let mut field_named_to_inter_by_class: HashMap<String, HashMap<String, String>> =
        HashMap::new();
    let mut field_inter_to_named_by_class: HashMap<String, HashMap<String, String>> =
        HashMap::new();
    if let Value::Object(map) = v {
        for (inter, obj) in map {
            let mut named_opt = None;
            if let Value::Object(obj_map) = obj {
                for (k, val) in obj_map {
                    if k == "mappedName" {
                        if let Some(named) = val.as_str() {
                            named_opt = Some(named.to_string());
                        }
                        continue;
                    }
                    if let Some(named) = val.as_str() {
                        method_named_to_inter_by_class
                            .entry(inter.clone())
                            .or_default()
                            .insert(named.to_string(), k.clone());
                        method_inter_to_named_by_class
                            .entry(inter.clone())
                            .or_default()
                            .insert(k.clone(), named.to_string());
                        field_named_to_inter_by_class
                            .entry(inter.clone())
                            .or_default()
                            .insert(named.to_string(), k.clone());
                        field_inter_to_named_by_class
                            .entry(inter.clone())
                            .or_default()
                            .insert(k.clone(), named.to_string());
                    }
                }
            }
            if let Some(named) = named_opt {
                class_named_to_inter.insert(named.clone(), inter.clone());
                class_inter_to_named.insert(inter.clone(), named.clone());
            }
        }
    }
    let class_maps = ClassMaps {
        yarn_named_to_inter: class_named_to_inter.clone(),
        yarn_inter_to_named: class_inter_to_named.clone(),
        moj_inter_to_named: HashMap::new(),
        moj_named_to_inter: HashMap::new(),
    };
    let method_maps = MemberMaps {
        yarn_named_to_inter_by_class: method_named_to_inter_by_class,
        yarn_inter_to_named_by_class: method_inter_to_named_by_class,
        moj_inter_to_named_by_class: HashMap::new(),
        moj_named_to_inter_by_class: HashMap::new(),
    };
    let field_maps = MemberMaps {
        yarn_named_to_inter_by_class: field_named_to_inter_by_class,
        yarn_inter_to_named_by_class: field_inter_to_named_by_class,
        moj_inter_to_named_by_class: HashMap::new(),
        moj_named_to_inter_by_class: HashMap::new(),
    };
    (class_maps, method_maps, field_maps)
}

fn build_maps_from_moj(v: &Value, mut c: ClassMaps, mut m: MemberMaps, mut f: MemberMaps) -> Maps {
    let mut class_inter_to_named = HashMap::new();
    let mut class_named_to_inter = HashMap::new();
    let mut method_inter_to_named_by_class: HashMap<String, HashMap<String, String>> =
        HashMap::new();
    let mut method_named_to_inter_by_class: HashMap<String, HashMap<String, String>> =
        HashMap::new();
    let mut field_inter_to_named_by_class: HashMap<String, HashMap<String, String>> =
        HashMap::new();
    let mut field_named_to_inter_by_class: HashMap<String, HashMap<String, String>> =
        HashMap::new();
    if let Value::Object(map) = v {
        for (inter, obj) in map {
            let mut named_opt = None;
            if let Value::Object(obj_map) = obj {
                for (k, val) in obj_map {
                    if k == "mappedName" {
                        if let Some(named) = val.as_str() {
                            named_opt = Some(named.to_string());
                        }
                        continue;
                    }
                    if let Some(named) = val.as_str() {
                        method_inter_to_named_by_class
                            .entry(inter.clone())
                            .or_default()
                            .insert(k.clone(), named.to_string());
                        method_named_to_inter_by_class
                            .entry(inter.clone())
                            .or_default()
                            .insert(named.to_string(), k.clone());
                        field_inter_to_named_by_class
                            .entry(inter.clone())
                            .or_default()
                            .insert(k.clone(), named.to_string());
                        field_named_to_inter_by_class
                            .entry(inter.clone())
                            .or_default()
                            .insert(named.to_string(), k.clone());
                    }
                }
            }
            if let Some(named) = named_opt {
                class_inter_to_named.insert(inter.clone(), named.clone());
                class_named_to_inter.insert(named.clone(), inter.clone());
            }
        }
    }
    c.moj_inter_to_named = class_inter_to_named.clone();
    c.moj_named_to_inter = class_named_to_inter.clone();
    m.moj_inter_to_named_by_class = method_inter_to_named_by_class;
    m.moj_named_to_inter_by_class = method_named_to_inter_by_class;
    f.moj_inter_to_named_by_class = field_inter_to_named_by_class;
    f.moj_named_to_inter_by_class = field_named_to_inter_by_class;
    Maps {
        class_maps: c,
        method_maps: m,
        field_maps: f,
    }
}

async fn prepare_maps(version: &str) -> anyhow::Result<Maps> {
    let yarn = fetch_mappings("yarn", version).await?;
    let moj = fetch_mappings("mojang", version).await?;
    let (c, m, f) = build_maps_from_yarn(&yarn);
    Ok(build_maps_from_moj(&moj, c, m, f))
}

#[derive(Clone, Copy)]
enum Ns {
    Yarn,
    Official,
}

fn ns_of(s: &str) -> Ns {
    match s.to_lowercase().as_str() {
        "yarn" => Ns::Yarn,
        _ => Ns::Official,
    }
}

struct Stats {
    converted: usize,
    failed: usize,
    failures: Vec<String>,
}

fn to_inter_class(maps: &Maps, ns: Ns, named: &str) -> String {
    match ns {
        Ns::Yarn => maps
            .class_maps
            .yarn_named_to_inter
            .get(named)
            .cloned()
            .unwrap_or_else(|| named.to_string()),
        Ns::Official => maps
            .class_maps
            .moj_named_to_inter
            .get(named)
            .cloned()
            .unwrap_or_else(|| named.to_string()),
    }
}

fn from_inter_class(maps: &Maps, ns: Ns, inter: &str) -> String {
    match ns {
        Ns::Yarn => maps
            .class_maps
            .yarn_inter_to_named
            .get(inter)
            .cloned()
            .unwrap_or_else(|| inter.to_string()),
        Ns::Official => maps
            .class_maps
            .moj_inter_to_named
            .get(inter)
            .cloned()
            .unwrap_or_else(|| inter.to_string()),
    }
}

fn to_inter_member(
    maps: &Maps,
    ns: Ns,
    owner_inter: &str,
    member_named: &str,
    is_method: bool,
) -> String {
    match (ns, is_method) {
        (Ns::Yarn, true) => maps
            .method_maps
            .yarn_named_to_inter_by_class
            .get(owner_inter)
            .and_then(|m| m.get(member_named))
            .cloned()
            .unwrap_or_else(|| member_named.to_string()),
        (Ns::Yarn, false) => maps
            .field_maps
            .yarn_named_to_inter_by_class
            .get(owner_inter)
            .and_then(|m| m.get(member_named))
            .cloned()
            .unwrap_or_else(|| member_named.to_string()),
        (Ns::Official, true) => maps
            .method_maps
            .moj_named_to_inter_by_class
            .get(owner_inter)
            .and_then(|m| m.get(member_named))
            .cloned()
            .unwrap_or_else(|| member_named.to_string()),
        (Ns::Official, false) => maps
            .field_maps
            .moj_named_to_inter_by_class
            .get(owner_inter)
            .and_then(|m| m.get(member_named))
            .cloned()
            .unwrap_or_else(|| member_named.to_string()),
    }
}

fn from_inter_member(
    maps: &Maps,
    ns: Ns,
    owner_inter: &str,
    member_inter: &str,
    is_method: bool,
) -> String {
    match (ns, is_method) {
        (Ns::Yarn, true) => maps
            .method_maps
            .yarn_inter_to_named_by_class
            .get(owner_inter)
            .and_then(|m| m.get(member_inter))
            .cloned()
            .unwrap_or_else(|| member_inter.to_string()),
        (Ns::Yarn, false) => maps
            .field_maps
            .yarn_inter_to_named_by_class
            .get(owner_inter)
            .and_then(|m| m.get(member_inter))
            .cloned()
            .unwrap_or_else(|| member_inter.to_string()),
        (Ns::Official, true) => maps
            .method_maps
            .moj_inter_to_named_by_class
            .get(owner_inter)
            .and_then(|m| m.get(member_inter))
            .cloned()
            .unwrap_or_else(|| member_inter.to_string()),
        (Ns::Official, false) => maps
            .field_maps
            .moj_inter_to_named_by_class
            .get(owner_inter)
            .and_then(|m| m.get(member_inter))
            .cloned()
            .unwrap_or_else(|| member_inter.to_string()),
    }
}

fn convert_desc_adv(
    desc: &str,
    from_named_to_inter: &HashMap<String, String>,
    to_inter_to_named: &HashMap<String, String>,
) -> String {
    let mut out = String::new();
    let mut i = 0;
    let bytes = desc.as_bytes();
    while i < bytes.len() {
        let c = bytes[i] as char;
        if c == 'L' {
            let mut j = i + 1;
            let mut class_buf = String::new();
            while j < bytes.len() {
                let cj = bytes[j] as char;
                if cj == '<' || cj == ';' {
                    break;
                }
                class_buf.push(cj);
                j += 1;
            }
            let inter = from_named_to_inter.get(&class_buf).cloned();
            let mapped_class = inter
                .as_ref()
                .and_then(|it| to_inter_to_named.get(it))
                .cloned()
                .unwrap_or_else(|| class_buf.clone());
            out.push('L');
            out.push_str(&mapped_class);
            if j < bytes.len() && bytes[j] as char == '<' {
                out.push('<');
                j += 1;
                let mut depth = 1;
                let mut segment = String::new();
                while j < bytes.len() && depth > 0 {
                    let cj = bytes[j] as char;
                    if cj == '<' {
                        depth += 1;
                        segment.push(cj);
                    } else if cj == '>' {
                        depth -= 1;
                        segment.push(cj);
                    } else {
                        segment.push(cj);
                    }
                    j += 1;
                }
                let converted_segment =
                    convert_desc_adv(&segment, from_named_to_inter, to_inter_to_named);
                out.push_str(&converted_segment);
                out.push('>');
            }
            while j < bytes.len() && bytes[j] as char != ';' {
                j += 1;
            }
            if j < bytes.len() && bytes[j] as char == ';' {
                out.push(';');
                j += 1;
            }
            i = j;
            continue;
        } else {
            out.push(c);
            i += 1;
        }
    }
    out
}

fn parse_aw_line(line: &str) -> Option<(String, String, Vec<String>)> {
    let trimmed = line.trim();
    if trimmed.is_empty() || trimmed.starts_with('#') {
        return None;
    }
    if trimmed.starts_with("accessWidener") {
        return None;
    }
    let parts: Vec<String> = trimmed.split_whitespace().map(|s| s.to_string()).collect();
    if parts.len() < 3 {
        return None;
    }
    Some((parts[0].clone(), parts[1].clone(), parts[2..].to_vec()))
}

fn build_at_line_class(owner_official: &str) -> String {
    format!("public {}", owner_official.replace('/', "."))
}

fn build_at_line_field(owner_official: &str, member_inter: &str) -> String {
    format!(
        "public {} {}",
        owner_official.replace('/', "."),
        member_inter
    )
}

fn build_at_line_method(owner_official: &str, member_inter: &str, desc_official: &str) -> String {
    format!(
        "public {} {}{}",
        owner_official.replace('/', "."),
        member_inter,
        desc_official
    )
}

fn build_aw_header(_ns: &str) -> String {
    "accessWidener v2 named".to_string()
}

fn is_disclaimer_line(s: &str) -> bool {
    let d = disclaimer_lines();
    let trimmed = s.trim();
    d.iter().any(|line| line.trim() == trimmed)
}

fn is_aw_header_line(s: &str) -> bool {
    let t = s.trim();
    t.starts_with("accessWidener v")
}

fn sanitize_aw_input_lines(lines: &[String]) -> Vec<String> {
    let mut out = Vec::with_capacity(lines.len());
    for l in lines {
        if is_disclaimer_line(l) || is_aw_header_line(l) {
            continue;
        }
        out.push(l.clone());
    }
    out
}

fn aw_to_at_lines(lines: &[String], maps: &Maps, aw_ns: &str) -> (Vec<String>, Stats) {
    let mut out: Vec<String> = Vec::new();
    let mut stats = Stats {
        converted: 0,
        failed: 0,
        failures: Vec::new(),
    };
    out.extend(disclaimer_lines());
    for line in lines {
        let raw = line.trim();
        if raw.is_empty() || raw.starts_with('#') {
            out.push(line.clone());
            continue;
        }
        if raw.starts_with("accessWidener") {
            continue;
        }
        let parsed = parse_aw_line(raw);
        if parsed.is_none() {
            continue;
        }
        let (_access, typ, rest) = parsed.unwrap();
        let ns = ns_of(aw_ns);
        if typ == "class" {
            let owner_named = rest.get(0).cloned().unwrap_or_default();
            let owner_inter = to_inter_class(maps, ns, &owner_named);
            let owner_official = from_inter_class(maps, Ns::Official, &owner_inter);
            out.push(build_at_line_class(&owner_official));
            if owner_inter == owner_named {
                stats.failed += 1;
                stats
                    .failures
                    .push(format!("class owner unmapped {}", owner_named));
            } else {
                stats.converted += 1;
            }
            continue;
        }
        if typ == "method" || typ == "field" {
            if rest.len() < 3 && typ == "method" {
                continue;
            }
            if rest.len() < 2 && typ == "field" {
                continue;
            }
            let owner_named = rest.get(0).cloned().unwrap_or_default();
            let name = rest.get(1).cloned().unwrap_or_default();
            let desc = if typ == "method" {
                rest.get(2).cloned().unwrap_or_default()
            } else {
                "".to_string()
            };
            let owner_inter = to_inter_class(maps, ns, &owner_named);
            let owner_official = from_inter_class(maps, Ns::Official, &owner_inter);
            if typ == "method" {
                let member_inter = to_inter_member(maps, ns, &owner_inter, &name, true);
                let desc_official = match ns {
                    Ns::Yarn => convert_desc_adv(
                        &desc,
                        &maps.class_maps.yarn_named_to_inter,
                        &maps.class_maps.moj_inter_to_named,
                    ),
                    Ns::Official => desc.clone(),
                };
                out.push(build_at_line_method(
                    &owner_official,
                    &member_inter,
                    &desc_official,
                ));
            } else {
                let member_inter = to_inter_member(maps, ns, &owner_inter, &name, false);
                out.push(build_at_line_field(&owner_official, &member_inter));
            }
            let fallback = owner_inter == owner_named
                || to_inter_member(maps, ns, &owner_inter, &name, typ == "method") == name;
            if fallback {
                stats.failed += 1;
                stats
                    .failures
                    .push(format!("member unmapped {}::{}", owner_named, name));
            } else {
                stats.converted += 1;
            }
            continue;
        }
    }
    (out, stats)
}

fn at_to_aw_lines(lines: &[String], maps: &Maps, target_aw_ns: &str) -> (Vec<String>, Stats) {
    let mut out: Vec<String> = Vec::new();
    let mut stats = Stats {
        converted: 0,
        failed: 0,
        failures: Vec::new(),
    };
    out.extend(disclaimer_lines());
    out.push(build_aw_header(target_aw_ns));
    for line in lines {
        let raw = line.trim();
        if raw.is_empty() || raw.starts_with('#') {
            out.push(line.clone());
            continue;
        }
        if !raw.starts_with("public")
            && !raw.starts_with("protected")
            && !raw.starts_with("private")
        {
            continue;
        }
        let mut parts = raw.split_whitespace();
        let _acc = parts.next();
        let owner_dotted = parts.next().unwrap_or("");
        let after_owner = parts.next().unwrap_or("");
        let owner_official = owner_dotted.replace('.', "/");
        let owner_inter = to_inter_class(maps, Ns::Official, &owner_official);
        let ns = ns_of(target_aw_ns);
        if after_owner.is_empty() {
            let owner_named = from_inter_class(maps, ns, &owner_inter);
            out.push(format!("accessible class {}", owner_named));
            if owner_named == owner_official {
                stats.failed += 1;
                stats
                    .failures
                    .push(format!("class owner unmapped {}", owner_official));
            } else {
                stats.converted += 1;
            }
            continue;
        }
        if after_owner.contains('(') {
            let mut name = String::new();
            let mut desc = String::new();
            if let Some(idx) = after_owner.find('(') {
                name = after_owner[..idx].to_string();
                desc = after_owner[idx..].to_string();
            } else {
                name = after_owner.to_string();
            }
            let member_inter = name.clone();
            let aw_name = from_inter_member(maps, ns, &owner_inter, &member_inter, true);
            let aw_desc = match ns {
                Ns::Yarn => convert_desc_adv(
                    &desc,
                    &maps.class_maps.moj_named_to_inter,
                    &maps.class_maps.yarn_inter_to_named,
                ),
                Ns::Official => desc.clone(),
            };
            let owner_named = from_inter_class(maps, ns, &owner_inter);
            out.push(format!(
                "accessible method {} {} {}",
                owner_named, aw_name, aw_desc
            ));
            let fallback = aw_name == member_inter && owner_named == owner_official;
            if fallback {
                stats.failed += 1;
                stats.failures.push(format!(
                    "method unmapped {}::{}",
                    owner_official, member_inter
                ));
            } else {
                stats.converted += 1;
            }
        } else {
            let member_inter = after_owner.to_string();
            let aw_name = from_inter_member(maps, ns, &owner_inter, &member_inter, false);
            let owner_named = from_inter_class(maps, ns, &owner_inter);
            out.push(format!("accessible field {} {}", owner_named, aw_name));
            let fallback = aw_name == member_inter && owner_named == owner_official;
            if fallback {
                stats.failed += 1;
                stats.failures.push(format!(
                    "field unmapped {}::{}",
                    owner_official, member_inter
                ));
            } else {
                stats.converted += 1;
            }
        }
    }
    (out, stats)
}

fn aw_to_aw_lines(
    lines: &[String],
    maps: &Maps,
    input_ns: &str,
    output_ns: &str,
) -> (Vec<String>, Stats) {
    let mut out: Vec<String> = Vec::new();
    let mut stats = Stats {
        converted: 0,
        failed: 0,
        failures: Vec::new(),
    };
    out.extend(disclaimer_lines());
    out.push(build_aw_header(output_ns));
    for line in lines {
        let raw = line.trim();
        if raw.is_empty() || raw.starts_with('#') {
            out.push(line.clone());
            continue;
        }
        if raw.starts_with("accessWidener") {
            continue;
        }
        let parsed = parse_aw_line(raw);
        if parsed.is_none() {
            continue;
        }
        let (_access, typ, rest) = parsed.unwrap();
        let in_ns_e = ns_of(input_ns);
        let out_ns_e = ns_of(output_ns);
        if typ == "class" {
            let owner_in_named = rest.get(0).cloned().unwrap_or_default();
            let owner_inter = to_inter_class(maps, in_ns_e, &owner_in_named);
            let owner_out_named = from_inter_class(maps, out_ns_e, &owner_inter);
            out.push(format!("accessible class {}", owner_out_named));
            if owner_out_named == owner_in_named {
                stats.failed += 1;
                stats
                    .failures
                    .push(format!("class owner unmapped {}", owner_in_named));
            } else {
                stats.converted += 1;
            }
            continue;
        }
        if typ == "method" || typ == "field" {
            if rest.len() < 3 && typ == "method" {
                continue;
            }
            if rest.len() < 2 && typ == "field" {
                continue;
            }
            let owner_in_named = rest.get(0).cloned().unwrap_or_default();
            let name_in = rest.get(1).cloned().unwrap_or_default();
            let desc_in = if typ == "method" {
                rest.get(2).cloned().unwrap_or_default()
            } else {
                "".to_string()
            };
            let owner_inter = to_inter_class(maps, in_ns_e, &owner_in_named);
            let name_inter = if typ == "method" {
                to_inter_member(maps, in_ns_e, &owner_inter, &name_in, true)
            } else {
                to_inter_member(maps, in_ns_e, &owner_inter, &name_in, false)
            };
            let owner_out_named = from_inter_class(maps, out_ns_e, &owner_inter);
            let name_out = if typ == "method" {
                from_inter_member(maps, out_ns_e, &owner_inter, &name_inter, true)
            } else {
                from_inter_member(maps, out_ns_e, &owner_inter, &name_inter, false)
            };
            if typ == "method" {
                let desc_out = match (in_ns_e, out_ns_e) {
                    (Ns::Yarn, Ns::Official) => convert_desc_adv(
                        &desc_in,
                        &maps.class_maps.yarn_named_to_inter,
                        &maps.class_maps.moj_inter_to_named,
                    ),
                    (Ns::Official, Ns::Yarn) => convert_desc_adv(
                        &desc_in,
                        &maps.class_maps.moj_named_to_inter,
                        &maps.class_maps.yarn_inter_to_named,
                    ),
                    _ => desc_in.clone(),
                };
                out.push(format!(
                    "accessible method {} {} {}",
                    owner_out_named, name_out, desc_out
                ));
            } else {
                out.push(format!("accessible field {} {}", owner_out_named, name_out));
            }
            let fallback = owner_out_named == owner_in_named && name_out == name_in;
            if fallback {
                stats.failed += 1;
                stats
                    .failures
                    .push(format!("member unmapped {}::{}", owner_in_named, name_in));
            } else {
                stats.converted += 1;
            }
        }
    }
    (out, stats)
}

fn read_lines(path: &Path) -> anyhow::Result<Vec<String>> {
    let content = std::fs::read_to_string(path)?;
    Ok(content.lines().map(|s| s.to_string()).collect())
}

fn write_lines(path: &Path, lines: &[String]) -> anyhow::Result<()> {
    let mut out = String::new();
    for (i, line) in lines.iter().enumerate() {
        out.push_str(line);
        if i + 1 < lines.len() {
            out.push('\n');
        } else {
            out.push('\n');
        }
    }
    std::fs::write(path, out)?;
    Ok(())
}

#[tauri::command]
pub async fn convert_aw_at(
    input_path: String,
    mc_version: String,
    direction: String,
    input_mapping: Option<String>,
    output_mapping: Option<String>,
    aw_output_name: Option<String>,
) -> Result<Value, String> {
    let maps = prepare_maps(&mc_version).await.map_err(|e| e.to_string())?;
    let p = Path::new(&input_path);
    if !p.exists() {
        return Err(format!("Input file not found: {}", input_path));
    }
    let mut lines = read_lines(p).map_err(|e| e.to_string())?;
    let dir = direction.to_lowercase();
    if dir == "aw_to_at" {
        lines = sanitize_aw_input_lines(&lines);
        let ns = input_mapping
            .clone()
            .unwrap_or_else(|| "official".to_string());
        let (out_lines, stats) = aw_to_at_lines(&lines, &maps, &ns);
        let out_path = p
            .parent()
            .unwrap_or_else(|| Path::new("."))
            .join("accesstransformer.cfg");
        write_lines(&out_path, &out_lines).map_err(|e| e.to_string())?;
        return Ok(json!({
            "outputPath": out_path.to_string_lossy(),
            "converted": stats.converted,
            "failed": stats.failed,
            "failures": stats.failures
        }));
    } else if dir == "at_to_aw" {
        lines = sanitize_aw_input_lines(&lines);
        let ns = output_mapping
            .clone()
            .unwrap_or_else(|| "official".to_string());
        let (out_lines, stats) = at_to_aw_lines(&lines, &maps, &ns);
        let out_name = aw_output_name.unwrap_or_else(|| "converted.accesswidener".to_string());
        let out_path = p.parent().unwrap_or_else(|| Path::new(".")).join(out_name);
        write_lines(&out_path, &out_lines).map_err(|e| e.to_string())?;
        return Ok(json!({
            "outputPath": out_path.to_string_lossy(),
            "converted": stats.converted,
            "failed": stats.failed,
            "failures": stats.failures
        }));
    } else if dir == "aw_to_aw" {
        lines = sanitize_aw_input_lines(&lines);
        let in_ns = input_mapping
            .clone()
            .unwrap_or_else(|| "official".to_string());
        let out_ns = output_mapping
            .clone()
            .unwrap_or_else(|| "official".to_string());
        let (out_lines, stats) = aw_to_aw_lines(&lines, &maps, &in_ns, &out_ns);
        let out_name = aw_output_name.unwrap_or_else(|| "converted.accesswidener".to_string());
        let out_path = p.parent().unwrap_or_else(|| Path::new(".")).join(out_name);
        write_lines(&out_path, &out_lines).map_err(|e| e.to_string())?;
        return Ok(json!({
            "outputPath": out_path.to_string_lossy(),
            "converted": stats.converted,
            "failed": stats.failed,
            "failures": stats.failures
        }));
    }
    Err("Unsupported direction".to_string())
}
